#!/usr/bin/perl -w  # -*- perl -*-
#
# $Id: allergy,v 1.3 2001-07-28 09:17:58 grahn Exp $
#
# Copyright (c) 2001 Jörgen Grahn <jgrahn@algonet.se>
# All rights reserved.
#
# allergy - build thumbnails and html code to present
# a number of photos as an 'album' or 'photo gallery'.
# 
use strict;

while(<>) {
    if(/^\s*\\begin{gallery}\s*$/) {
	gallery();
    }
    else {
	print;
    }
}

sub gallery {
    my ($columns, $class, $dx, $dy, $texpr);
    my @files = ();

    while(<>) {
	chomp;
	last if /^\s*\\end{gallery}\s*$/;

      SWITCH: {
	  /^\s*$/ and last SWITCH;
	  /\\grid{(\d+).+}/ and $columns = $1, last SWITCH;
	  /\\class{(.+?)}/ and $class = $1, last SWITCH;
	  /\\bounded{(\d+),(\d+)}/ and ($dx,$dy) = ($1,$2), last SWITCH;
	  /\\thumb{(.+)}/ and $texpr = $1, last SWITCH;

	  @files = (@files, explode($_));
	}
    }

    @files = normalize(@files);

    table($columns, $class, $dx, $dy, $texpr, @files);
}

sub explode {
    my $s = shift;
    my ($pat, $templ);

    if($s =~ /\s*(.+?)\s*:\s*(.+)/) {
	($pat, $templ) = ($1, $2);
    }
    elsif($s =~ /\s*(.+?)\s*/) {
	($pat, $templ) = ($1, "");
    }
    else {
	die "malformed line\n";
    }

    map {"$_ : $templ"} glob $pat;
}

sub normalize {
    my @names = @_;
    my ($i, $j);

    # remove duplicates, keeping the first
    # yes, this is *ugly*...
    for($i=0; $i<@names; $i++) {
	for($j=$i+1; $j<@names; $j++) {
	    my ($in) = $names[$i] =~ /(.+?)\s:/;
	    my ($jn) = $names[$j] =~ /(.+?)\s:/;
	    $names[$j] = "dead :" if $in eq $jn;
	}
    }
    @names = grep !/^dead :$/, @names;

    # names beginning with underscore are assumed to
    # be thumbnails, skip them
    grep !/^_/, @names;
}

sub table {
    my $columns = shift;
    my $class = shift;
    my $dx = shift;
    my $dy = shift;
    my $texpr = shift;
    my @files = @_;

    print "<table class=\"$class\">\n";

    my $i = 0;

    foreach (@files) {
	print "<tr>\n" unless $i % $columns;
	print "<td>";
	image($dx, $dy, $texpr, $_);

	$i++;
    }

    print "</table>\n";
}

sub image {
    my $dx = shift;
    my $dy = shift;
    my $texpr = shift;
    my ($file, $text) = shift =~ /(.+?)\s:\s(.+)/;
    $_ = $file;
    eval("$texpr");
    my $tfile = $_;

    my ($ddx, $ddy) = thumb($dx, $dy, $tfile, $file);

    print "<a href=\"$file\">\n",
    "  <img src=\"$tfile\" alt=\"[$tfile]\"\n",
    "  width=\"$ddx\", height=\"$ddy\"></a>",

#    print "$tfile\n";
}

sub thumb {
    my $dx = shift;
    my $dy = shift;
    my $tfile = shift;
    my $file = shift;

    my %decoder = ("jpg" => "djpeg",
		   "jpeg" => "djpeg",
		   "png" => "pngtopnm");
    my $quality = 30;

    if(-f $tfile and -M $tfile < -M $file) {
	print STDERR "$file\n";
    }
    else {
	my ($suffix) = $file =~ /.+\.(.+)/;
	$suffix = lc $suffix;

	# decode to PNM, let pnmscale do bounding-box scaling,
	# and encode to JPEG.
	#
	print STDERR "$file: thumbnailing... ";
	system "<\"$file\" $decoder{$suffix} | " .
	    "pnmscale -xysize $dx $dy | " .
	    "cjpeg -quality $quality > \"$tfile\"";
	print STDERR "$tfile\n";
    }

    # return dimensions of thumbnail
    #
    open SIZE, "$decoder{jpg} <\"$tfile\" | pnmfile |" or die;
    <SIZE> =~ /(\d+) by (\d+)/ and
	my ($ddx, $ddy) = ($1, $2);
    close SIZE;

    ($ddx, $ddy);
}
