#!/usr/bin/perl -w  # -*- perl -*-
#
# $Id: allergy,v 1.10 2001-10-01 22:28:38 grahn Exp $
# $Name:  $
#
# Copyright (c) 2001 Jörgen Grahn <jgrahn@algonet.se>
# All rights reserved.
#
# allergy - build thumbnails and html code to present
# a number of photos as an 'album' or 'photo gallery'.
# 
use strict;

while(<>) {
    if(/^\s*\\begin{gallery}\s*$/) {
	gallery();
    }
    else {
	print;
    }
}

sub gallery {
    my ($columns, $class, $quality, $dx, $dy, $texpr) =
	(4,
	 "",
	 30,
	 140, 100,
	 "s/(.+)\\..+/_\$1.jpg/");
    my @files = ();


    while(<>) {
	chomp;
	last if /^\s*\\end{gallery}\s*$/;

      SWITCH: {
	  /^\s*$/ and last SWITCH;
	  /^\s*\#/ and last SWITCH;
	  /\\grid{(\d+).+}/ and $columns = $1, last SWITCH;
	  /\\class{(.+?)}/ and $class = $1, last SWITCH;
	  /\\quality{(\d+)}/ and $quality = $1, last SWITCH;
	  /\\bounded{(\d+),(\d+)}/ and ($dx,$dy) = ($1,$2), last SWITCH;
	  /\\thumb{(.+)}/ and $texpr = $1, last SWITCH;
	  /^\\/ and last SWITCH;

	  @files = (@files, explode($_));
	}
    }

    @files = normalize(@files);

    table($columns, $class, $quality, $dx, $dy, $texpr, @files);
}

sub explode {
    my $s = shift;
    my ($pat, $templ);


    if($s =~ /\s*(.+?)\s*:\s*(.+)/) {
	($pat, $templ) = ($1, $2);
    }
    elsif($s =~ /\s*(\S+)\s*/) {
	($pat, $templ) = ($1, "");
    }
    else {
	die "malformed line\n";
    }

    map {"$_ : $templ"} glob $pat;
}

sub normalize {
    my @names = @_;
    my ($i, $j);

    # remove duplicates, keeping the first
    # yes, this is *ugly*...
    for($i=0; $i<@names; $i++) {
	for($j=$i+1; $j<@names; $j++) {
	    my ($in) = $names[$i] =~ /(.+?)\s:/;
	    my ($jn) = $names[$j] =~ /(.+?)\s:/;
	    $names[$j] = "dead :" if $in eq $jn;
	}
    }
    @names = grep !/^dead :$/, @names;

    # names beginning with underscore are assumed to
    # be thumbnails, skip them
    grep !/^_/, @names;
}

sub table {
    my $columns = shift;
    my $class = shift;
    my $quality = shift;
    my $dx = shift;
    my $dy = shift;
    my $texpr = shift;
    my @files = @_;


    if(defined $class and ! $class eq "") {
	print "<table class=\"$class\">\n";
    }
    else  {
	print "<table>\n";
    }

    my $i = 0;

    foreach (@files) {
	my ($name, $text) = /(.+?)\s:\s(.*)/;

	print "<tr>\n" unless $i % $columns;
	print "<td>";

	image($quality, $dx, $dy, $texpr, $name);

	my $dimension = "";
	my $size = "";
	print eval("\"<br>$text\\n\"")
	    unless $text eq "";

	$i++;
    }

    print "</table>\n";
}

sub image {
    my $quality = shift;
    my $dx = shift;
    my $dy = shift;
    my $texpr = shift;
    my $file = shift;
    $_ = $file;

    eval("$texpr");
    my $tfile = $_;

    my ($ddx, $ddy) = thumb($quality, $dx, $dy, $tfile, $file);

    if($ddx && $ddy) {
	print "<a href=\"$file\">\n",
	"  <img src=\"$tfile\" alt=\"[$file]\"\n",
	"  width=\"$ddx\" height=\"$ddy\"></a>\n";
    }
    else {
	print "<a href=\"$file\">\n",
	"  $file\n",
	"  </a>\n";
    }
}

sub thumb {
    my $quality = shift;
    my $dx = shift;
    my $dy = shift;
    my $tfile = shift;
    my $file = shift;
    my $suffix;

    my %decoder = ("jpg"  => "djpeg",
		   "jpeg" => "djpeg",
		   "gif"  => "giftopnm",
		   "png"  => "pngtopnm",
		   "ilbm" => "ilbmtoppm",
		   "iff"  => "ilbmtoppm");

    unless(($suffix) = $file =~ /.+\.(.+)/ and
       $suffix = lc $suffix and
       defined $decoder{$suffix}) {

	print STDERR "$file cannot be thumbnailed, skipping\n";

	return (0,0);
    }

    if(! -f $file) {
	print STDERR "$file does not exist, skipping\n";
	return (0,0);
    }
    elsif(-f $tfile and -M $tfile < -M $file) {
	print STDERR "$file\n";
    }
    else {
	($suffix) = $file =~ /.+\.(.+)/;
	$suffix = lc $suffix;

	# decode to PNM, let pnmscale do bounding-box scaling,
	# and encode to JPEG.
	#
	print STDERR "$file: thumbnailing... ";
	system "<\"$file\" $decoder{$suffix} | " .
	    "pnmscale -xysize $dx $dy | " .
	    "cjpeg -quality $quality > \"$tfile\"";
	print STDERR "$tfile\n";
    }

    # return dimensions of thumbnail
    #
    open SIZE, "$decoder{jpg} <\"$tfile\" | pnmfile |" or die;
    <SIZE> =~ /(\d+) by (\d+)/ and
	my ($ddx, $ddy) = ($1, $2);
    close SIZE;

    return ($ddx, $ddy);
}
