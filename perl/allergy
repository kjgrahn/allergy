#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
#
# $Id: allergy,v 1.31 2005-07-07 12:27:22 grahn Exp $
# $Name:  $
#
# Copyright (c) 2001, 2004, 2005 Jörgen Grahn <jgrahn@algonet.se>
# All rights reserved.
#
"""allergy - build thumbnails and html code to present
a number of photos as an 'album' or 'photo gallery'.
"""
import Image
import glob
import re
import os.path
import os
import sys

class Any:
    "The wildcard object."
    def __cmp__(self, other): return 0
ANY = Any()

class Feedback:
    """Configurable feedback generator; prints to stderr
    when called.
    """
    def __init__(self, verbosity=2):
        if verbosity==0:
            self.__call__ = self.nop
        elif verbosity==1:
            self.__call__ = self.dot
        else:
            self.__call__ = self.string
        self.final_nl = 0
    def close(self):
        if self.final_nl:
            sys.stderr.write('\n')
            sys.stderr.flush()
    def string(self, s):
        print >>sys.stderr, s
        sys.stderr.flush()
    def dot(self, s):
        sys.stderr.write('.')
        sys.stderr.flush()
        self.final_nl = 1
    def nop(self, s):
        pass

class Photobase:
    """Parsing the text/photos file.
    I can't be bothered to write its format down just now; see
    allergy(1) for the quick version.
    """
    class ParseError(Exception):
        pass
    emptyre = re.compile(r'^\s*$')
    commentre = re.compile(r'^#')
    def __init__(self, path):
        self.things = {}
        state = 0
        line = 0
        f = open(path, 'r')
        for s in f.xreadlines():
            s = s.rstrip()
            line += 1
            if state==0:
                if self.emptyre.match(s) or self.commentre.match(s):
                    continue
                filename = s
                text = []
                state = 1
                continue
            if state==1:
                state = 2
                time = s
                continue
            if state==2:
                s = s.strip()
                if s:
                    text.append(s)
                    continue
                state = 0
                self.things[filename] = (filename, time, ' '.join(text))
        if state==2:
            self.things[filename] = (filename, time, ' '.join(text))
        elif state!=0:
            raise self.ParseError, line
    def has(self, file):
        "Do we have info on the image file 'file'?"
        return self.things.has_key(file)
    def text(self, file):
        "The descriptive text for the image file 'file'."
        filename, time, text = self.things[file]
        return text.replace('"', "'")

class ExifTime:
    """Pulling the time a photo was taken from
    the EXIF information it contains, if at all possible.
    """
    def __call__(self, f):
        """Return the generation time embedded in image file 'f' as a
        tuple ('yyyy-mm-dd', 'hh:mm') or, for all kinds of errors and
        subnormal conditions, None.

        We prefer 'Image Generated' attributes to other time stamps,
        because it's supposed to be the one closest to the actual
        snapshot moment.
        """
        try:
            tags = self.EXIF.process_file(open(f, 'rb'))
            for id in ('EXIF DateTimeGenerated',
                       'EXIF DateTimeDigitized',
                       'Image DateTime'):
                if tags.has_key(id):
                    date, time = str(tags[id]).split()
                    # I like my dates in the semi-formal sv_SE form 7.7.2005
                    date = map(int, date.split(':'))
                    date.reverse()
                    date = '%d.%d.%d' % tuple(date)
                    return (date, time[:5])
        except:
            pass
        return None

    try:
        import EXIF
    except ImportError:
        pass

class DescriptionDb:
    """Container for all sources of image information, except
    that in the allergy source itself. This means, in practice,
    the text/photos file and EXIF information embedded in the
    images themselves. Both of these may be absent.
    """
    def __init__(self, photobase = None):
        self.photobase = photobase
        self.exiftime = ExifTime()
    def title(self, file):
        "A suitable title for the image file 'file', or the empty string."
        t = []
        datetime = self.exiftime(file)
        if datetime:
            date, time = datetime
            t.append(date)
        if self.photobase and self.photobase.has(file):
            t.append(self.photobase.text(file))
        return '. '.join(t)

def make(a, b, clobber=1):
    """Return true iff file 'a' needs to be regenerated
    from 'b', i.e. if it doesn't exist or is older than 'b'.
    If clobber is false, only non-existing 'a' need
    (re)generation.
    May raise os.error, aka OSError."""
    try:
        am = os.path.getmtime(a)
    except os.error:
        return 1
    if not clobber: return 0
    bm = os.path.getmtime(b)
    return am <= bm

def thumbname(path):
    """Return the thumbnail file name corresponding
    to an image name, i.e. prepend an underscore and
    append a .jpg suffix (killing any existing suffix)."""
    head, tail = os.path.split(path)
    tail, ext = os.path.splitext(tail)
    tail = '_%s.jpg' % tail
    return os.path.join(head, tail)

def gridentry(href, thumbnail, caption):
    """Format an object (probably an image) as a grid item,
    with an existing thumbnail image and describing text."""
    html = []
    html.append('<td><a href="%s">' % href)
    html.append('   <img src="%s"' % thumbnail)
    html.append('        alt="[%s]"' % thumbnail)
    if caption:
        html.append('      title="%s"' % caption)
    html.append('  width="%d" height="%d"></a>' % Image.open(thumbnail).size)
    return '\n'.join(html)

def listentry(href, thumbnail, caption):
    """Format an object (probably an image) as a list item,
    with an existing thumbnail image and describing text."""
    html = []
    html.append('<p><a href="%s">' % href)
    html.append('  <img src="%s"' % thumbnail)
    html.append('      alt="[%s]"' % thumbnail)
    html.append('  width="%d" height="%d"></a>' % Image.open(thumbnail).size)
    if caption:
        html.append(caption)
    html.append('<br>')
    return '\n'.join(html)

class Gallery:
    """Main parser and gallery generator. After fed the lines
    contained within a begin/end{gallery}, do() generates
    thumbnails and corresponding HTML."""
    gridre = re.compile(r'\\grid{\s*(\d+)\s*,\s*n}')
    listre = re.compile(r'\\list{}')
    classre = re.compile(r'\\class{\s*(.+?)\s*}')
    boundedre = re.compile(r'\\bounded{(\d+),(\d+)}')
    qualityre = re.compile(r'\\quality{(\d+)}')
    commentre = re.compile(r'\s*(#.+)?$')
    annotre = re.compile(r'(.+?)\s*:\s*(.+)')
    def __init__(self, feedback, descdb=None, clobber=1):
        self.descdb = descdb
        self.clobber = clobber
        self.feedback = feedback
        self.columns = 4
        self.formatter = gridentry
        self.cls = ''
        self.quality = 30
        self.bbox = (140, 100)
        self.images = []
    def add(self, line):
        "Parse a source line of the gallery definition"
        m = self.commentre.match(line)
        if m: return
        m = self.gridre.match(line)
        if m:
            self.columns = int(m.group(1))
            self.formatter = gridentry
            return
        m = self.listre.match(line)
        if m:
            self.columns = None
            self.formatter = listentry
            return
        m = self.classre.match(line)
        if m:
            self.cls = ' class="%s"' % m.group(1)
            return
        m = self.boundedre.match(line)
        if m:
            self.bbox = tuple(map(int, m.groups()))
            return
        m = self.qualityre.match(line)
        if m:
            self.quality = int(m.group(1))
            return
        m = self.annotre.match(line)
        if m:
            (pat, caption) = m.groups()
            self.images.append((pat, [caption]))
            return
        if not line[0].isspace():
            self.images.append((line.strip(), []))
        else:
            self.images[-1][1].append(line)
            return
    def do(self):
        """Execute the gallery, performing thumbnailing as
        appropriate. Returns a string containing the HTML for this
        gallery."""
        images = []
        html = []
        for pat, caption in self.images:
            pats = glob.glob(pat)
            pats.sort()
            for image in pats:
                if image[0] != '_' and not (image, ANY) in images:
                    images.append((image, ' '.join(caption)))
        if not images:
            return ''
        if self.columns:
            html.append('<table%s>' % self.cls)
        else:
            html.append('<div%s>' % self.cls)
        n = 0
        for f, caption in images:
            tf = thumbname(f)
            if make(tf, f, self.clobber):
                i = Image.open(f)
                i.thumbnail(self.bbox)
                if i.mode=='P':
                    i = i.convert('RGB')
                self.feedback('%s, thumbnailing' % f)
                i.save(thumbname(f), 'JPEG', quality=self.quality)
            else:
                self.feedback(f)
                i = Image.open(tf)
            if self.columns and n % self.columns == 0:
                html.append('<tr>')
            if not caption:
                caption = self.descdb.title(f)
            html.append(self.formatter(f, tf, caption))
            n += 1
        if self.columns:
            html.append('</table>')
        else:
            html.append('</div>')
        self.feedback.close()
        return '\n'.join(html)


if __name__ == "__main__":
    import getopt
    import fileinput

    usage = 'usage: allergy [-f file] [-k] [-v | -V] file ...'

    try:
        opts, files = getopt.getopt(sys.argv[1:], 'f:kvV')
    except getopt.GetoptError, s:
        print >>sys.stderr, s
        print >>sys.stderr, usage
        sys.exit(1)
    clobber = 1
    verbosity = 0
    photobase = None
    for option, value in opts:
        if option == '-f': photobase = Photobase(value)
        if option == '-k': clobber = 0
        if option == '-v': verbosity = 2
        if option == '-V': verbosity = 1

    descdb = DescriptionDb(photobase)
    ingallery = 0

    for line in fileinput.input(files):
        if ingallery:
            if line.count(r'\end{gallery}'):
                print gallery.do()
                ingallery = 0
            else:
                gallery.add(line)
        else:
            if line.count(r'\begin{gallery}'):
                ingallery = 1
                gallery = Gallery(Feedback(verbosity), descdb, clobber)
            else:
                print line[:-1]
