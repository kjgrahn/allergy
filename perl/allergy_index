#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
#
# $Id: allergy_index,v 1.16 2008-08-05 20:14:49 grahn Exp $
# $Name:  $
#
# Copyright (c) 2008 Jörgen Grahn <grahn+src@snipabacken.se>
# All rights reserved.
#
"""build a html photo index
"""
import re
import os
import BaseHTTPServer
import time
import gzip

from photobase import Photobase

def reversedate(s):
    """Transform a standard 'yyyy-mm-dd' date string
    to the less formal 'd.m.yyyy' format popular in Sweden.
    """
    date = map(int, s.split('-'))
    date.reverse()
    return '%d.%d.%d' % tuple(date)

def _escape(s):
    s = s.replace('<', '&lt;')
    s = s.replace('>', '&gt;')
    s = s.replace('&', '&amp;')
    return s

class Generator(object):

    def _generate_index(self, f):
        w = f.write
        w('<h1><a name="by_keyword">Foton efter nyckelord</a></h1>\n'
          '\n'
          '<p>\n')
        kk = self._pb.keys.keys()
        kk.sort(key = str.lower)
        for k in kk:
            w('<h2><a name="%s">%s</a></h2>\n' % (k, k))
            w('<ul>\n')
            pb = self._pb.keys[k][:]
            pb.sort(key = lambda x: x.datetime, reverse = False)
            pdate = pdesc = None
            for p in pb:
                date, time = p.datetime.split(None, 2)
                desc = p.description
                if pdate != date:
                    pdate = date
                else:
                    date = ''
                if pdesc != desc:
                    pdesc = desc
                else:
                    desc = ''
                w('<li>%10s %5s &mdash; %s\n' % (date, time,
                                                 escape(desc)))
            w('</ul>\n')


def _cvs_says(dollarname='$Name:  $'):
    m = re.match(r'\$'r'Name:\s+(.+?)-(\d+(-\d+)*)\D', dollarname)
    if not m: return ('allergy', 'unknown')
    return m.group(1), m.group(2).replace('-', '.')


def _date_time_string(epochtime):
    """Return 'epochtime' formatted for a message header,
    i.e. as a rfc1123-date. Stolen from BaseHTTPServer.
    """
    weekdayname = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')
    monthname = (None,
                 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(epochtime)
    s = "%s, %02d %3s %4d %02d:%02d:%02d GMT" % (
            weekdayname[wd],
            day, monthname[month], year,
            hh, mm, ss)
    return s

_months = {1: 'januari', 2: 'februari', 3: 'mars',
           4: 'april', 5: 'maj', 6: 'juni',
           7: 'juli', 8: 'augusti', 9: 'september',
           10: 'oktober', 11: 'november', 12: 'december'}

def _year_month_index(photobase, href, w):
    """An index over years and months.
    """
    # XXX We mess with the original ...
    by_date = photobase.photos
    by_date.sort(key = lambda x: x.datetime, reverse = True)
    months = {}
    for p in by_date:
        y, m, _ = p.datetime.split('-', 2)
        ym = (int(y), int(m))
        months[ym] = None
    months = months.keys()
    months.sort(reverse=True)
    firstyear, _ = months[0]
    lastyear, _ = months[-1]
    w('<ul>\n')
    for y in xrange(firstyear, lastyear-1, -1):
        ref = href(y)
        if ref:
            w('<li><a href="%s">%04d</a>:'% (ref, y))
        else:
            w('<li>%04d:'% y)
        for m in range(1, 13):
            if (y, m) in months:
                ref = href(y, m)
                w(' <a href="%s">%s</a>' % (ref, _months[m]))
            else:
                w(' %s' % _months[m])
        w('\n')
    w('</ul>\n')


def _huge_alpha_index(things, href, w):
    """Render a HTML index for string sequence 'things' by writing through 'w'.
    'href' is a function which creates an URI for a thing.
    The index gets sorted in alphabetical order.
    """
    def _one_letter(title, things, href, w):
        if not things:
            return
        w('<h2>%s</h2>\n' % title)
        w('<p>')
        acc = []
        for t in things:
            name = _escape(t)
            ref = href(t)
            acc.append('<a href="%s">%s</a>' % (ref, name))
        w(' &mdash; '.join(acc))
        w('\n')
    things = things[:]
    things.sort()
    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ'
    for initial in letters:
        _one_letter(initial,
                    [ x for x in things if x[0].upper() == initial ],
                    href, w)
    _one_letter('...',
                [ x for x in things if x[0].upper() not in letters ],
                href, w)

class Handler(BaseHTTPServer.BaseHTTPRequestHandler):
    """Handler for one request. Except for the inherited stuff
    and the domain-specific stuff, it supports generating
    an Expires: header and transparent 'gzip' Transfer-Encoding.
    """
    server_version = '%s/%s' % _cvs_says()

    def do_GET(self):
        p = self.path
        server = self.server
        self.gzfile = None
        if p in ('/', '/index.html'):
            self.get_index()
        elif p in ('/keywords', '/key', '/key/'):
            self.get_keywords()
        elif p.startswith('/key/'):
            self.get_key(p[5:])
        elif p=='/by-date':
            self.get_by_date()
        elif p=='/css':
            self.get_css()
        elif p=='/robots.txt':
            self.get_robots()
        else:
            self.get_404('not found')

    def get_index(self):
        server = self.server
        self.preamble('Foton: index', contents=None)
        w = self.write
        w('<h1>Innehåll</h1>\n'
          '\n'
          '<ul>\n'
          '<li><a href="/by-date">Foton efter datum</a> (senaste först)\n')
        w('<li>Foton för ett år, eller en månad:\n')
        def ympages(y, m=None):
            if not m:
                return '/%04d' % y
            return '/%04d-%02d' % (y, m)
        _year_month_index(server.photobase, ympages, w)
        w('<li><a href="/keywords">Index till nyckelord</a>\n'
          '</ul>\n'
          '\n')
        self.postamble()

    def get_keywords(self):
        server = self.server
        self.preamble('Index till nyckelord', up='/')
        w = self.write
        w('<h1>Index till nyckelord</h1>\n')
        keys = server.photobase.keys.keys()
        def href(key):
            return '/key/' + key
        _huge_alpha_index(keys, href, w)
        self.postamble()

    def get_key(self, key):
        photobase = self.server.photobase
        try:
            pp = photobase.keys[key]
        except KeyError:
            return self.get_404('Inga foton finns för nyckelord "%s".' % key)
        pp.sort(key = lambda x: x.datetime, reverse = True)
        self.preamble('Foton för %s' % key, up='/keywords')
        w = self.write
        w('<h1>Foton för <cite>%s</cite></h1>\n' % key)

        w('<ul>\n')
        pdate = pdesc = None
        for p in pp:
            date, time = p.datetime.split(None, 2)
            y, m, _ = p.datetime.split('-', 2)
            desc = p.description
            if pdate != date:
                pdate = date
            else:
                date = ''
            if pdesc != desc:
                pdesc = desc
            else:
                desc = ''
            w('<li><tt>%10s %5s</tt> &mdash; %s\n' % (date, time,
                                                      _escape(desc)))
        w('</ul>\n')

        self.postamble()

    def get_by_date(self):
        server = self.server
        self.preamble('Alla foton, efter datum', up='/')
        w = self.write
        w('<h1>Alla foton, efter datum</h1>\n')

        def href(y, m=None):
            if not m:
                return None
            return '#%04d-%02d' % (y, m)

        _year_month_index(server.photobase, href, w)

        # XXX We mess with the original ...
        by_date = photobase.photos
        by_date.sort(key = lambda x: x.datetime, reverse = True)

        pym = pdate = pdesc = None
        for p in by_date:
            date, time = p.datetime.split(None, 2)
            y, m, _ = p.datetime.split('-', 2)
            desc = p.description
            if pym != (y, m):
                if pym is not None:
                    w('</ul>\n')
                w('<h2><a name="%s-%s">%s %s</a></h2>\n' % (y, m, _months[int(m)], y))
                w('<ul>\n')
                pym = y, m
            if pdate != date:
                pdate = date
            else:
                date = ''
            if pdesc != desc:
                pdesc = desc
            else:
                desc = ''
            w('<li><tt>%10s %5s</tt> &mdash; %s\n' % (date, time,
                                                      _escape(desc)))
        w('</ul>\n')

        self.postamble()

    def get_robots(self):
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain; charset=ISO-8859-1')
        self.send_expires_header()
        self.end_headers()
        self.write('User-agent: *\n'
                   'Disallow: /\n')
        self.close()

    def get_css(self):
        self.send_response(200)
        self.send_header('Content-Type', 'text/css')
        self.send_expires_header()
        self.end_headers()
        w = self.write
        w('BODY {\n'
          '	background-color: rgb(255,224,160);\n'
          '	color: black\n'
          '}\n')
        w('*.latin {\n'
          '	font-style: italic\n'
          '}\n')
        w('ul { list-style-type: none }\n')
        w('a { text-decoration: none }\n')
        w('a:hover { text-decoration: underline }\n')
        self.close()

    def get_404(self, s):
        self.send_response(404)
        self.send_header('Content-Type', 'text/plain; charset=ISO-8859-1')
        self.send_expires_header()
        self.end_headers()
        self.write(s)
        self.close()

    def preamble(self, title,
                 contents='/', up=None,
                 start=None, prev=None, next=None):
        """write HTTP headers for a successful HTML GET,
        plus everything to the HTML body.
        """
        self.send_response(200)
        self.send_header('Content-Type', 'text/html; charset=ISO-8859-1')
        self.send_expires_header()
        self.end_headers()
        w = self.write
        w('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"\n'
          '"http://www.w3.org/TR/html4/strict.dtd">\n'
          '<html>\n'
          '\n'
          '<head>\n'
          '<meta http-equiv="Content-Language" content="sv">\n'
          '<link rel="stylesheet" href="/css" type="text/css" title="plain">\n')
        for type, uri in (('contents', contents),
                          ('up', up),
                          ('start', start),
                          ('prev', prev),
                          ('next', next)):
            if uri:
                w('<link rel="%s" href="%s">' % (type, uri))
        w('<title>%s</title>\n' % title)
        w('</head>\n'
          '\n'
          '<body>\n')

    def postamble(self):
        self.write('</body>\n'
                   '</html>\n')
        self.close()

    def end_headers(self, try_gzip=True):
        """Except from the base end_headers(), also optionally prepare the
        response for Content-Encoding:gzip, if the client is prepared
        for it. Modifies what the write() and close() calls will
        do. Ugly, but then so is BaseHTTPServer ...
        """
        z = try_gzip and self.accepts_gzip_te()
        if z:
            self.send_header('Content-Encoding', 'gzip')
        BaseHTTPServer.BaseHTTPRequestHandler.end_headers(self)
        if z:
            self.gzfile = gzip.GzipFile(mode='ab',
                                        fileobj=self.wfile)

    def send_expires_header(self, n=3*60):
        """Send an 'Expires' header, set to 'n' seconds from now.
        """
        self.send_header('Expires', _date_time_string(time.time() + n))

    def accepts_gzip_te(self):
        """True iff the client accepts 'gzip' transfer encoding.
        XXX Possibly only defined from within do_FOO.
        """
        te = self.headers.get('Accept-Encoding', '')
        return 'gzip' in [s.strip() for s in te.split(',')]

    def write(self, s):
        if self.gzfile:
            self.gzfile.write(s)
        else:
            self.wfile.write(s)

    def close(self):
        """Logically close the output file (something we only do to
        the gzip stream; someone else owns the socket lifetime).
        """
        if self.gzfile:
            self.gzfile.close()        


class Server(BaseHTTPServer.HTTPServer):
    def __init__(self, address, photobase):
        BaseHTTPServer.HTTPServer.__init__(self, address, Handler)
        self.photobase = photobase


if __name__ == "__main__":
    import getopt
    import sys

    prog = os.path.basename(sys.argv[0])

    usage = 'usage: %s -f descriptions-file ... -b photo-url -p photo-path http://hostname:port' % prog
    usage += '\n       %s --version' % prog
    usage += '\n       %s --help   ' % prog

    try:
        opts, baseurl = getopt.getopt(sys.argv[1:], 'f:b:p:',
                                      ['help',
                                       'version'])
        descriptions = []
        pbaseurl = None
        pbasepath = None
        for option, value in opts:
            if option == '-f': descriptions.append(value)
            if option == '-b': pbaseurl = value
            if option == '-p': pbasepath = value
            if option == '--help':
                print usage
                sys.exit(0)
            if option == '--version':
                print prog
                print '%s, version %s' % _cvs_says()
                print 'Copyright (c) 2008 Jörgen Grahn.'
                sys.exit(0)
        if len(descriptions)==0 or len(baseurl)!=1 or not pbasepath or not pbaseurl:
            raise ValueError('required argument missing')
        m = re.match(r'http://(\w*?):(\d+)', baseurl[0])
        if not m:
            raise ValueError('incorrect base URL')
        host, port = m.groups(); port = int(port)

    except (ValueError, getopt.GetoptError), s:
        print >>sys.stderr, 'error:', s
        print >>sys.stderr, usage
        sys.exit(1)

    try:
        photobase = Photobase(descriptions)
        Server((host, port), photobase).serve_forever()
    except KeyboardInterrupt:
        pass
